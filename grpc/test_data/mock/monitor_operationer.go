// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/purposeinplay/go-commons/grpc"
	"sync"
)

// Ensure, that MonitorOperationerMock does implement grpc.MonitorOperationer.
// If this is not the case, regenerate this file with moq.
var _ grpc.MonitorOperationer = &MonitorOperationerMock{}

// MonitorOperationerMock is a mock implementation of grpc.MonitorOperationer.
//
//	func TestSomethingThatUsesMonitorOperationer(t *testing.T) {
//
//		// make and configure a mocked grpc.MonitorOperationer
//		mockedMonitorOperationer := &MonitorOperationerMock{
//			MonitorOperationFunc: func(ctx context.Context, name string, traceID [16]byte, operationFunc func(context.Context))  {
//				panic("mock out the MonitorOperation method")
//			},
//		}
//
//		// use mockedMonitorOperationer in code that requires grpc.MonitorOperationer
//		// and then make assertions.
//
//	}
type MonitorOperationerMock struct {
	// MonitorOperationFunc mocks the MonitorOperation method.
	MonitorOperationFunc func(ctx context.Context, name string, traceID [16]byte, operationFunc func(context.Context))

	// calls tracks calls to the methods.
	calls struct {
		// MonitorOperation holds details about calls to the MonitorOperation method.
		MonitorOperation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// TraceID is the traceID argument value.
			TraceID [16]byte
			// OperationFunc is the operationFunc argument value.
			OperationFunc func(context.Context)
		}
	}
	lockMonitorOperation sync.RWMutex
}

// MonitorOperation calls MonitorOperationFunc.
func (mock *MonitorOperationerMock) MonitorOperation(ctx context.Context, name string, traceID [16]byte, operationFunc func(context.Context)) {
	if mock.MonitorOperationFunc == nil {
		panic("MonitorOperationerMock.MonitorOperationFunc: method is nil but MonitorOperationer.MonitorOperation was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Name          string
		TraceID       [16]byte
		OperationFunc func(context.Context)
	}{
		Ctx:           ctx,
		Name:          name,
		TraceID:       traceID,
		OperationFunc: operationFunc,
	}
	mock.lockMonitorOperation.Lock()
	mock.calls.MonitorOperation = append(mock.calls.MonitorOperation, callInfo)
	mock.lockMonitorOperation.Unlock()
	mock.MonitorOperationFunc(ctx, name, traceID, operationFunc)
}

// MonitorOperationCalls gets all the calls that were made to MonitorOperation.
// Check the length with:
//
//	len(mockedMonitorOperationer.MonitorOperationCalls())
func (mock *MonitorOperationerMock) MonitorOperationCalls() []struct {
	Ctx           context.Context
	Name          string
	TraceID       [16]byte
	OperationFunc func(context.Context)
} {
	var calls []struct {
		Ctx           context.Context
		Name          string
		TraceID       [16]byte
		OperationFunc func(context.Context)
	}
	mock.lockMonitorOperation.RLock()
	calls = mock.calls.MonitorOperation
	mock.lockMonitorOperation.RUnlock()
	return calls
}
